# -*- coding:utf8 -*-


def odd(n):
    '''
    奇数
    :return:
    '''
    return (n * 3) + 1


def even(n):
    '''
    偶数
    :return:
    '''
    return n / 2


def is_even(input):
    if (input % 2) == 0:
        return True
    return False


def calc(input):
    # n が 偶数の場合、nを2で割る
    # n が 奇数の場合、nに3をかけて1を足す
    n = input
    if is_even(n):
        n = odd(n)

    while True:
        if is_even(n):
            n = even(n)
        else:
            n = odd(n)

        # 数字が1になるか元の数になれば、ループを終了
        if n == input:
            return True
        if n == 1:
            return False


def main():
   '''
   コラッツの予想
   自然数nについて
   * nが偶数の場合、nを2で割る
   * nが奇数の場合、nに3をかけて1を足す
   という操作を繰り返すとき、初期値がどんな数であっても必ず1に到達する（1 -> 4 -> 2 -> 1のように繰り返す）

   これをちょっとかえて、初期値が偶数の場合、初回のみnに3をかけて1を足すことから始めることとし、「最初の数」に戻るものを考えます。

   例えば、2ではじめた場合は以下のようになります。
   2 -> 7 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2

   同様に、4で始めると以下のようになります。
   4 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4

   しかし、6で始めると
   6 -> 19 -> 58 -> 29 -> 88 -> 44 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4
    -> 2 -> 1 -> 4 -> ...
   となり、6に戻ってくることはありません。
   :return: None

   10000以下の偶数のうち、2や4のような「最初の数に戻る数」がいくつあるか、その個数を求めなさい。
   '''

   for i in range(1, 10001):
       if is_even(i):
           if calc(i):
               print(i)

if __name__ == '__main__':
    main()
